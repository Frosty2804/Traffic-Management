import { featureCollection, } from "@turf/helpers";
import explode from "@turf/explode";
import roundCoord from "./round-coord";
export default function createTopology(network, options = {}) {
    const { key = defaultKey } = options;
    const { tolerance = 1e-5 } = options;
    const lineStrings = featureCollection(network.features.filter((f) => f.geometry.type === "LineString"));
    const points = explode(lineStrings);
    const vertices = points.features.reduce(function buildTopologyVertices(coordinates, feature, index, features) {
        var rc = roundCoord(feature.geometry.coordinates, tolerance);
        coordinates[key(rc)] = feature.geometry.coordinates;
        if (index % 1000 === 0 && options.progress) {
            options.progress("topo:vertices", index, features.length);
        }
        return coordinates;
    }, {});
    const edges = geoJsonReduce(lineStrings, buildTopologyEdges, []);
    return {
        vertices: vertices,
        edges: edges,
    };
    function buildTopologyEdges(edges, f) {
        f.geometry.coordinates.forEach(function buildLineStringEdges(c, i, cs) {
            if (i > 0) {
                var k1 = key(roundCoord(cs[i - 1], tolerance)), k2 = key(roundCoord(c, tolerance));
                edges.push([k1, k2, f.properties]);
            }
        });
        return edges;
    }
}
function geoJsonReduce(geojson, fn, seed) {
    if (geojson.type === "FeatureCollection") {
        return geojson.features.reduce(function reduceFeatures(a, f) {
            return geoJsonReduce(f, fn, a);
        }, seed);
    }
    else {
        return fn(seed, geojson);
    }
}
export function defaultKey(c) {
    return c.join(",");
}
//# sourceMappingURL=topology.js.map