"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.pathToGeoJSON = void 0;
const helpers_1 = require("@turf/helpers");
const compactor_1 = require("./compactor");
const dijkstra_1 = __importDefault(require("./dijkstra"));
const preprocessor_1 = __importDefault(require("./preprocessor"));
const round_coord_1 = __importDefault(require("./round-coord"));
const topology_1 = require("./topology");
class PathFinder {
    constructor(network, options = {}) {
        this.graph = (0, preprocessor_1.default)(network, options);
        this.options = options;
        // if (
        //   Object.keys(this.graph.compactedVertices).filter(function (k) {
        //     return k !== "edgeData";
        //   }).length === 0
        // ) {
        //   throw new Error(
        //     "Compacted graph contains no forks (topology has no intersections)."
        //   );
        // }
    }
    findPath(a, b) {
        const { key = topology_1.defaultKey, tolerance = 1e-5 } = this.options;
        const start = key((0, round_coord_1.default)(a.geometry.coordinates, tolerance));
        const finish = key((0, round_coord_1.default)(b.geometry.coordinates, tolerance));
        // We can't find a path if start or finish isn't in the
        // set of non-compacted vertices
        if (!this.graph.vertices[start] || !this.graph.vertices[finish]) {
            return undefined;
        }
        const phantomStart = this._createPhantom(start);
        const phantomEnd = this._createPhantom(finish);
        try {
            const pathResult = (0, dijkstra_1.default)(this.graph.compactedVertices, start, finish);
            if (pathResult) {
                const [weight, path] = pathResult;
                return {
                    path: path
                        .reduce((coordinates, vertexKey, index, vertexKeys) => {
                        if (index > 0) {
                            coordinates = coordinates.concat(this.graph.compactedCoordinates[vertexKeys[index - 1]][vertexKey]);
                        }
                        return coordinates;
                    }, [])
                        .concat([this.graph.sourceCoordinates[finish]]),
                    weight,
                    edgeDatas: "edgeDataReducer" in this.options
                        ? path.reduce((edges, vertexKey, index, vertexKeys) => {
                            if (index > 0) {
                                edges.push(this.graph.compactedEdges[vertexKeys[index - 1]][vertexKey]);
                            }
                            return edges;
                        }, [])
                        : undefined,
                };
            }
            else {
                return undefined;
            }
        }
        finally {
            this._removePhantom(phantomStart);
            this._removePhantom(phantomEnd);
        }
    }
    _createPhantom(n) {
        if (this.graph.compactedVertices[n])
            return undefined;
        const phantom = (0, compactor_1.compactNode)(n, this.graph.vertices, this.graph.compactedVertices, this.graph.sourceCoordinates, this.graph.edgeData, true, this.options);
        this.graph.compactedVertices[n] = phantom.edges;
        this.graph.compactedCoordinates[n] = phantom.coordinates;
        if ("edgeDataReducer" in this.options) {
            this.graph.compactedEdges[n] = phantom.reducedEdges;
        }
        Object.keys(phantom.incomingEdges).forEach((neighbor) => {
            this.graph.compactedVertices[neighbor][n] =
                phantom.incomingEdges[neighbor];
            if (!this.graph.compactedCoordinates[neighbor]) {
                this.graph.compactedCoordinates[neighbor] = {};
            }
            this.graph.compactedCoordinates[neighbor][n] = [
                this.graph.sourceCoordinates[neighbor],
                ...phantom.incomingCoordinates[neighbor].slice(0, -1),
            ];
            if (this.graph.compactedEdges) {
                if (!this.graph.compactedEdges[neighbor]) {
                    this.graph.compactedEdges[neighbor] = {};
                }
                this.graph.compactedEdges[neighbor][n] = phantom.reducedEdges[neighbor];
            }
        });
        return n;
    }
    _removePhantom(n) {
        if (!n)
            return;
        Object.keys(this.graph.compactedVertices[n]).forEach((neighbor) => {
            delete this.graph.compactedVertices[neighbor][n];
        });
        Object.keys(this.graph.compactedCoordinates[n]).forEach((neighbor) => {
            delete this.graph.compactedCoordinates[neighbor][n];
        });
        if ("edgeDataReducer" in this.options) {
            Object.keys(this.graph.compactedEdges[n]).forEach((neighbor) => {
                delete this.graph.compactedEdges[neighbor][n];
            });
        }
        delete this.graph.compactedVertices[n];
        delete this.graph.compactedCoordinates[n];
        if (this.graph.compactedEdges) {
            delete this.graph.compactedEdges[n];
        }
    }
}
exports.default = PathFinder;
function pathToGeoJSON(path) {
    if (path) {
        const { weight, edgeDatas } = path;
        return (0, helpers_1.lineString)(path.path, { weight, edgeDatas });
    }
}
exports.pathToGeoJSON = pathToGeoJSON;
//# sourceMappingURL=index.js.map