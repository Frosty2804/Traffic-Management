"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const tinyqueue_1 = __importDefault(require("tinyqueue"));
function findPath(graph, start, end) {
    const costs = { [start]: 0 };
    const initialState = [0, [start], start];
    const queue = new tinyqueue_1.default([initialState], (a, b) => a[0] - b[0]);
    while (true) {
        const state = queue.pop();
        if (!state) {
            return undefined;
        }
        const cost = state[0];
        const node = state[2];
        if (node === end) {
            return [state[0], state[1]];
        }
        const neighbours = graph[node];
        Object.keys(neighbours).forEach(function (n) {
            var newCost = cost + neighbours[n];
            if (newCost < Infinity && (!(n in costs) || newCost < costs[n])) {
                costs[n] = newCost;
                const newState = [newCost, state[1].concat([n]), n];
                queue.push(newState);
            }
        });
    }
}
exports.default = findPath;
//# sourceMappingURL=dijkstra.js.map