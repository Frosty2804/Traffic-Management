"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const distance_1 = __importDefault(require("@turf/distance"));
const helpers_1 = require("@turf/helpers");
const compactor_1 = __importDefault(require("./compactor"));
const topology_1 = __importDefault(require("./topology"));
function preprocess(network, options = {}) {
    const topology = (0, topology_1.default)(network, options);
    const { weight = defaultWeight } = options;
    const graph = topology.edges.reduce(reduceEdges, {
        edgeData: {},
        vertices: {},
    });
    const { vertices: compactedVertices, coordinates: compactedCoordinates, edgeData: compactedEdges, } = (0, compactor_1.default)(graph.vertices, topology.vertices, graph.edgeData, options);
    return {
        vertices: graph.vertices,
        edgeData: graph.edgeData,
        sourceCoordinates: topology.vertices,
        compactedVertices,
        compactedCoordinates,
        compactedEdges,
    };
    function reduceEdges(g, edge, i, es) {
        const [a, b, properties] = edge;
        const w = weight(topology.vertices[a], topology.vertices[b], properties);
        if (w) {
            makeEdgeList(a);
            makeEdgeList(b);
            // If the weight for an edge is falsy, it means the edge is impassable;
            // we still add the edge to the graph, but with a weight of Infinity,
            // since this makes compaction easier.
            // After compaction, we remove any edge with a weight of Infinity.
            if (w instanceof Object) {
                concatEdge(a, b, w.forward || Infinity);
                concatEdge(b, a, w.backward || Infinity);
            }
            else {
                concatEdge(a, b, w || Infinity);
                concatEdge(b, a, w || Infinity);
            }
        }
        if (i % 1000 === 0 && options.progress) {
            options.progress("edgeweights", i, es.length);
        }
        return g;
        function makeEdgeList(node) {
            if (!g.vertices[node]) {
                g.vertices[node] = {};
                g.edgeData[node] = {};
            }
        }
        function concatEdge(startNode, endNode, weight) {
            var v = g.vertices[startNode];
            v[endNode] = weight;
            g.edgeData[startNode][endNode] =
                "edgeDataReducer" in options
                    ? options.edgeDataSeed(properties)
                    : undefined;
        }
    }
}
exports.default = preprocess;
function defaultWeight(a, b) {
    return (0, distance_1.default)((0, helpers_1.point)(a), (0, helpers_1.point)(b));
}
//# sourceMappingURL=preprocessor.js.map